Securing Workloads

O que veremos ?
\_1. Introducing the concept of Zero-trust Architecture.
\_2. Exploring Istio's Authentication resource and its configurations.
\_3. Explaining how encrypted traffic is handled in Istio.
\_4. Discussing the role of authentication after authentication.
\_5. Explaining how Istio's Authorization resource controls access using fine-grained policies.
\_6. Analyzing the complexity involved in managing authorization rules.
\_7. Emphasizing the importance of security for the exam preparation.
\_8. Beginning with a focus on understanting authorization fundamentals.

Agora vamos falar de um conceito chamado "Zero Trust".
É meio que auto explicativo, que basicamente significa nunca confie, sempre verifique. Por exemplo;
\_Você confia nesse ip ?
\_Você confia nessa app ?
\_Você confia nessa identidade ?
\_E por ai vai.....

O istio faz isso implementando MTLS para toda comunicação um ponto importante para se observar é que o Istio 
não impõe o Zero Trust por padrão você precisa configurar isso. E você faz isso configurando o Peer 
Authentication, que podem ser restritivos ou permissivos.

E por que usar Peer Authentication ?
\_Zero-Trust principles
\_Encrypts traffic between services
\_Prevents unauthorized access
\_Protects services
\_Services identity verification

Boa, agora vc já sabe né ? É hora de Hands-on maravilhoso......

Como sempre comece verificando as labels;
\_kubectl get ns --show-labels

Entregue a app HelloWorld;
\_kubectl apply -f ~/istio/samples/helloworld/helloworld.yaml
  \_Verifique;
     \_kubectl get pods

Estando tudo certo vamos em frente e vamos criar um novo namespace;
\_kubectl create ns test
  \_Rode um pod de teste dentro desse novo namespace;
    \_kubectl run test --image=nginx -n test
      \_Verifique;
        \_kubectl -n test get pod

Agora rode uma chamada curl do pod de test para o helloworld;
\_kubectl exec -ti -n test test -- curl http://helloworld.default.svc:5000/hello
  \_É esperado um => Hello version: v2, instance: helloworld-v2-779454bb5f-ggcn2
    \_Recebemos um 200 porque por padrão a comunicação é aberta no istio

Agora, vamos aplicar o PeerAuthenticationGlobal;
\_vim peer_auth_global.yaml

apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT

Aplique;
\_kubectl apply -f peer_auth_global.yaml
  \_Verifique;
    \_kubectl get peerauthentications.security.istio.io -A

Boua, agora repita o curl de teste e veja que vc vai receber um Deny;
\_kubectl exec -ti -n test test -- curl http://helloworld.default.svc:5000/hello
   \_É esperado algo como;
curl: (56) Recv failure: Connection reset by peer
command terminated with exit code 56

Show, agora vamos fazer o seguinte, vamos remover o pod de teste, rotular o namespace com o istio, deployar 
novamente o pod de test e depois do pod up vamos fazer uma chamada de test curl novamente;
\_kubectl -n test delete pod test
  \_kubectl label namespace test istio-injection=enabled
    \_kubectl run test --image=nginx -n test
       \_kubectl -n test get pod
          \_kubectl exec -ti -n test test -- curl http://helloworld.default.svc:5000/hello
	    \_é esperado um 200 aqui 

Boa, agora vamos fazer uma regra de sobreposição vamos sobrepor uma regra sobre a regra global;
\_vim peer_auth_default.yaml

apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: default
spec:
  mtls:
    mode: PERMISSIVE

Aplique;
\_kubectl apply -f peer_auth_default.yaml

Boa agora que criamos um peer permissivo, vamos criar um novo namespace, não rotulado;
\_kubectl create ns app
  \_Rode uma app de teste nesse novo namespace;
    \_kubectl run test --image=nginx -n app

Show, rode o comando show-labels e veja que o namespace default e test tem o istio injetado e namespace app não;
\_kubectl get ns --show-labels

NAME              STATUS   AGE     LABELS
app               Active   2m30s   kubernetes.io/metadata.name=app
default           Active   54d     istio-injection=enabled,kubernetes.io/metadata.name=default
istio-system      Active   5d4h    kubernetes.io/metadata.name=istio-system
kube-node-lease   Active   54d     kubernetes.io/metadata.name=kube-node-lease
kube-public       Active   54d     kubernetes.io/metadata.name=kube-public
kube-system       Active   54d     kubernetes.io/metadata.name=kube-system
test              Active   22m     istio-injection=enabled,kubernetes.io/metadata.name=test

Show agora vamos rodar uma um curl partindo do pod no novo namespace;
\_kubectl exec -ti -n app test -- curl --head http://helloworld.default.svc:5000/hello
  \_É esperado um 200

Evidentemente porque o peer authentication que criamos é permissivo.
Show vamos em frente e agora vamos deployar a app bookinfo no namespace default;
\_kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.11/samples/bookinfo/platform/kube/bookinfo.yaml
  \_Verifique e espere até que todos os pods estejam 2/2
     \_kubectl get pods

Agora faça uma nova chamada curl;
\_kubectl exec -ti -n app test -- curl --head http://helloworld.default.svc:5000/hello
  \_É esperado um 200 aqui;
    \_Rode um novo curl porem agora aponte para  app productpage;
      \_kubectl exec -ti -n app test -- curl --head http://productpage.default.svc:9080
        \_É esperado um => Recv failure: Connection reset by peer, isso porque a liberação que fizemos é especifica para a app helloworld


Boa é isso por enquanto sobre peer authentication, vamos ver agora sobre Authorization =)

Limpando o lab;
\_kubectl delete -f https://raw.githubusercontent.com/istio/istio/release-1.11/samples/bookinfo/platform/kube/bookinfo.yaml
\_kubectl delete -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/helloworld/helloworld.yaml
\_kubectl get pod
\_kubectl get ns 
\_kubectl delete ns app test
\_kubectl delete -f peer_auth_default.yaml
\_kubectl delete -f peer_auth_global.yaml
