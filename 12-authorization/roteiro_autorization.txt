Authorization

Simplesmente define o que pode ser feito em termos de request no workload do istio, por exemplo, qual workload pode ou não fazer
um POST, ou um GET, quando necessário controlar isso entre os namespaces.

Bom vamos de Hands-on que é pra alegrar o dia;
(Mais uma vez estou partindo do principio que você esta com o cluster de k8s "limpo" e com o istio instalado e com o namespace 
default com istio injetado)

Verifique o lab;
\_kubectl get ns --show-labels
   \_Confirme de o namespace default possui o istio injetado

Show, estando tudo certo entregue a app httpbin no namespace default;
\_kubectl apply -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/httpbin/httpbin.yaml
  \_Verifique;
    \_kubectl get pods

Caso não exista crie um namespace com o nome test e entregue uma app de test nesse namespace.

Rode um curl do pod de test apontando para o httpbin;
\_kubectl exec -ti -n test test -- curl --head http://httpbin.default.svc:8000
HTTP/1.1 200 OK
access-control-allow-credentials: true
access-control-allow-origin: *
content-security-policy: default-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' camo.githubusercontent.com
content-type: text/html; charset=utf-8
date: Thu, 04 Sep 2025 23:17:44 GMT
x-envoy-upstream-service-time: 13
server: envoy
transfer-encoding: chunked

Boa, tudo certo vamos em frente e vamos comaçar ativando o mTLS;
\_vim peer_auth_global.yaml

apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT

Aplique;
\_kubectl apply -f peer_auth_global.yaml
  \_Verifique;
    \_kubectl get peerauthentications.security.istio.io -n istio-system

Agora vamos em frente e vamos criar um policy;
\_vim auth_policy.yaml

apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: httpbin-auth-policy
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["test"]
      to:
        - operation:
            methods: ["GET"]

Aplique;
\_kubectl apply -f auth_policy.yaml
  \_Verifique;
     \_kubectl get authorizationpolicies.security.istio.io

Boa, agora rode uma nova chamada curl;
\_kubectl exec -ti -n test test -- curl --head http://httpbin.default.svc:8000
   \_Agora é esperado um 403 e isso é o esperado pois nossa chamada é do tipo HEAD, vamos repetir a chamada sem o head
     \_kubectl exec -ti -n test test -- curl http://httpbin.default.svc:8000
       \_Agora é esperado um 200, caso você queira ver o head funcionando você precisa adicionar isso auth_policy
         \_vim auth_policy.yaml

apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: httpbin-auth-policy
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["test"]
      to:
        - operation:
            methods: ["GET", "HEAD"]

	    Aplique;
	    \_kubectl apply -f auth_policy.yaml
	      \_Refaça a chamada curl com o head;
	        \_ kubectl exec -ti -n test test -- curl --head http://httpbin.default.svc:8000
		  \_Veja que agora retorna um 200

Caso seu lab não tenha, crie um namespace com o nome app e injete o istio nele, também faça a entrega de um pod de test.
(Sim não sem sequencias de comandos aqui até esse momento já fizemos isso em outros labs ....)

Show, estando tudo certo rode uma chamada curl de dentro do pod de test para a app httpbin;
\_kubectl exec -ti test -n app -- curl --head httpbin.default.svc:8000
  \_Aqui é esperado um 403, devido o fato de apenas o namespace test pode receber chamadas, Vamos ajustar isso adicionando o namespace app.
    \_vim auth_policy.yaml

apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: httpbin-auth-policy
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["test", "app"]
      to:
        - operation:
            methods: ["GET", "HEAD"]

Aplique;
\_kubectl apply -f auth_policy.yaml
  \_Rode uma nova chamada curl;
    \_kubectl exec -ti test -n app -- curl --head httpbin.default.svc:8000
      \_Agora é esperado um 200
        \_Show, maravilha agora vamos remover essa atual policy e vamos criar uma de DENY;
	   \_kubectl delete -f auth_policy.yaml

Boa, com a policy removida vamos criar uma nova;
\_vim auth_policy_deny.yaml

apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: httpbin-auth-deny-policy
  namespace: default
spec:
  action: DENY
  rules:
    - to:
        - operation:
            paths: ["/delay"]

Aplique;
\_kubectl apply -f auth_policy_deny.yaml
  \_Você vai receber o seguinte alerta;
     Warning: configured AuthorizationPolicy will deny all traffic to TCP ports under its scope due to the use of only HTTP attributes in a DENY rule; it is recommended to explicitly specify the port
     authorizationpolicy.security.istio.io/httpbin-auth-deny-policy created
     \_Esta tudo bem, siga em frente, volte no auth_policy.yaml e deixe ele assim;

apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: httpbin-auth-policy
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["test"]
      to:
        - operation:
            methods: ["GET", "HEAD"]
            paths: ["/get"]

Aplique;
\_kubectl apply -f auth_policy.yaml

Show agora rode um curl partindo do namespace test para o httpbin;
\_kubectl exec -ti test -n app -- curl http://httpbin.default.svc:8000/delay/1
  \_Agora é esperado um => RBAC: access denied
    \_Agora rode um novo curl, mas aponte para o /GET, rode primeiro partindo do namespace test depois do name space app;
      \_kubectl exec -ti test -n test -- curl http://httpbin.default.svc:8000/get
      \_kubectl exec -ti test -n app -- curl http://httpbin.default.svc:8000/get
        \_Agora você recebe um 200, veja que do namespace app é negado e do name space test é liberado, o que é totalmente esperado pois apenas o namespace test esta liberado.
          \_Boua, vamos em frente e vamos ajustar nossa policy, porém agora vamos  usar o selector para isso;
	    \_vim auth_policy.yaml

apiVersion: security.istio.io/v1 
kind: AuthorizationPolicy
metadata:
  name: httpbin-auth-policy
spec:
  action: ALLOW
  selector:
    matchLabels:
      app: httpbin
  rules:
    - from:
        - source:
            namespaces: ["app"]
      to:
        - operation:
            methods: ["GET", "HEAD"]
            paths: ["/get"]

Aplique;
\_kubectl apply -f auth_policy.yaml
  \_Faça um novo teste de chamada curl partindo do namespace app e veja que agora ele responde enquanto o namespace test não responde mais;
    \_kubectl exec -ti test -n app -- curl http://httpbin.default.svc:8000/get
    \_kubectl exec -ti test -n test -- curl http://httpbin.default.svc:8000/get

Show agora rode a app bookinfo;
\_kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.11/samples/bookinfo/platform/kube/bookinfo.yaml
  \_Verifique;
    \_kubectl get pod
      \_Aguaede todos os pods ficarem 2/2

Um ponto de observação é, sempre tome cuidado com politicas de DENY e ALLOW no istio porque por padrão as policys de DENY sempre vencem. Isso posto, vamos fazer uma policy que negue tudo;
\_vim auth_deny_all.yaml

apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: default
spec:
  action: DENY
  rules:
  - {}


Aplique;
\_kubectl apply -f auth_deny_all.yaml
  \_Agora rode um curl partindo do namespace app;
    \_kubectl exec -ti test -n app -- curl --head http://httpbin.default.svc:8000/get
      \_Você vai receber um 403
         \_Agora delete a policy DenyAll;
	    \_kubectl delete -f auth_deny_all.yaml
	       \_Agora rode novamente o curl;
	         \_kubectl exec -ti test -n app -- curl --head http://httpbin.default.svc:8000/get
		   \_É esperado um 200

Boa, isso é apenas para mostrar como que um deny-all vai bloquear tudo.
Vamos em frente e como entregamos a app bookinfo, vamos fazer algumas chamadas curl para ela, para ver seu retorno;
\_kubectl exec -ti test -n app -- curl --head http://productpage.default.svc:9080/productpage
  \_É esperado um 200 aqui, vamos agora criar uma regra que bloqueie apenas a app bookinfo;
    \_vim auth_deny_product.yaml

apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all-product
spec:
  selector:
    matchLabels:
      app: productpage
  action: DENY
  rules:
    - {}

Aplique;
\_kubectl apply -f auth_deny_product.yaml
   \_Rode uma nova chamada curl para a app bookinfo e isso deve retornar um 403;
     \_kubectl exec -ti test -n app -- curl --head http://productpage.default.svc:9080/productpage
       \_Caso vc esteja se perguntando se uma chamada para a app httpbin funcionaria, rode uma chamada curl apontando pra ela e veja;
         \_kubectl exec -ti test -n app -- curl --head http://httpbin.default.svc:8000/get
	   \_Show né ? =D

Boua, e isso é tudo por enquanto para o nosso lab de Authorization, vamos em frente e agora vamos falar de outro tema importante, que é Workload Entry.
Então "limpe" o lab e sigua em frente.


